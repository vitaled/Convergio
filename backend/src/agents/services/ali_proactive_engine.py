"""
ðŸ¤– Ali Proactive Intelligence Engine
Advanced proactive monitoring and autonomous decision-making system for super intelligent orchestration
Based on Claude Sonnet 4 August 2025 optimization patterns
"""

import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
import structlog
from dataclasses import dataclass, asdict
import json
import uuid
from enum import Enum

logger = structlog.get_logger()

class InsightType(Enum):
    """Types of proactive insights Ali can generate"""
    RESOURCE_OPTIMIZATION = "resource_optimization"
    PERFORMANCE_IMPROVEMENT = "performance_improvement"
    COST_OPTIMIZATION = "cost_optimization"
    TEAM_PRODUCTIVITY = "team_productivity"
    RISK_MITIGATION = "risk_mitigation"
    STRATEGIC_OPPORTUNITY = "strategic_opportunity"
    SYSTEM_HEALTH = "system_health"
    GOVERNANCE = "governance"

class Priority(Enum):
    """Insight priority levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class ActionStatus(Enum):
    """Status of autonomous actions"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    ESCALATED = "escalated"

@dataclass
class ProactiveInsight:
    """Proactive insight generated by Ali's intelligence engine"""
    id: str
    insight_type: InsightType
    priority: Priority
    title: str
    description: str
    recommended_actions: List[str]
    confidence_score: float  # 0.0 to 1.0
    data_sources: List[str]
    business_impact: str
    risk_assessment: str
    generated_at: datetime
    expires_at: Optional[datetime] = None
    auto_executable: bool = False
    related_agents: List[str] = None

    def __post_init__(self):
        if self.related_agents is None:
            self.related_agents = []

@dataclass
class SystemAnomaly:
    """System anomaly detected by monitoring"""
    id: str
    anomaly_type: str
    severity: Priority
    affected_components: List[str]
    impact_assessment: str
    auto_resolution_available: bool
    escalation_required: bool
    detected_at: datetime
    resolution_eta: Optional[datetime] = None

@dataclass
class AutonomousAction:
    """Autonomous action taken by Ali"""
    id: str
    action_type: str
    description: str
    insight_id: str
    status: ActionStatus
    agents_involved: List[str]
    parameters: Dict[str, Any]
    started_at: datetime
    completed_at: Optional[datetime] = None
    result: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None

class AliProactiveEngine:
    """
    Ali's Proactive Intelligence Engine
    
    Continuously monitors system state, business metrics, and team performance
    to generate autonomous insights and execute intelligent interventions.
    """
    
    def __init__(self):
        self.monitoring_active = False
        self.insights_generated: List[ProactiveInsight] = []
        self.anomalies_detected: List[SystemAnomaly] = []
        self.autonomous_actions: List[AutonomousAction] = []
        self.intervention_history: List[Dict[str, Any]] = []
        
        # Performance metrics
        self.metrics = {
            "insights_generated_today": 0,
            "autonomous_actions_taken": 0,
            "success_rate": 0.0,
            "average_confidence": 0.0,
            "system_health_score": 100.0
        }
        
        # Monitoring intervals (in seconds)
        self.business_monitoring_interval = 300  # 5 minutes
        self.system_monitoring_interval = 60    # 1 minute
        self.performance_monitoring_interval = 180  # 3 minutes
        
        logger.info("ðŸ§  Ali Proactive Intelligence Engine initialized")
    
    async def start_continuous_monitoring(self):
        """Start Ali's continuous proactive monitoring"""
        if self.monitoring_active:
            logger.warning("âš ï¸ Monitoring already active")
            return
        
        self.monitoring_active = True
        logger.info("ðŸ” Ali proactive monitoring activated - becoming super intelligent")
        
        # Start all monitoring tasks in parallel using asyncio.gather
        monitoring_tasks = [
            self._monitor_business_metrics(),
            self._monitor_system_health(),
            self._monitor_team_performance(),
            self._monitor_financial_metrics(),
            self._detect_patterns_and_trends(),
            self._execute_autonomous_actions(),
            self._cleanup_expired_insights()
        ]
        
        try:
            await asyncio.gather(*monitoring_tasks, return_exceptions=True)
        except Exception as e:
            logger.error("Monitoring system error", error=str(e))
            self.monitoring_active = False
    
    async def stop_monitoring(self):
        """Stop proactive monitoring"""
        self.monitoring_active = False
        logger.info("ðŸ›‘ Ali proactive monitoring stopped")
    
    async def _monitor_business_metrics(self):
        """Monitor business KPIs and generate strategic insights"""
        while self.monitoring_active:
            try:
                # Import tools here to avoid circular imports
                from agents.tools.database_tools import DatabaseTools
                
                # Get current business data
                projects_data = await DatabaseTools.get_projects_overview()
                talents_data = await DatabaseTools.get_talents_summary()
                
                # Generate business insights
                insights = await self._analyze_business_patterns(projects_data, talents_data)
                
                # Process each insight
                for insight in insights:
                    await self._process_proactive_insight(insight)
                
                logger.debug("ðŸ“Š Business metrics monitoring cycle completed")
                
            except Exception as e:
                logger.error("Business monitoring error", error=str(e))
            
            await asyncio.sleep(self.business_monitoring_interval)
    
    async def _monitor_system_health(self):
        """Monitor technical system health and performance"""
        while self.monitoring_active:
            try:
                from agents.tools.database_tools import DatabaseTools
                
                # Get system health data
                health_data = await DatabaseTools.get_system_health()
                
                # Analyze system health
                anomalies = await self._detect_system_anomalies(health_data)
                
                # Process anomalies
                for anomaly in anomalies:
                    await self._handle_system_anomaly(anomaly)
                    self.anomalies_detected.append(anomaly)
                
                # Update health score
                self._update_system_health_score(health_data)
                
                logger.debug("ðŸ”§ System health monitoring cycle completed")
                
            except Exception as e:
                logger.error("System health monitoring error", error=str(e))
            
            await asyncio.sleep(self.system_monitoring_interval)
    
    async def _monitor_team_performance(self):
        """Monitor team productivity and collaboration patterns"""
        while self.monitoring_active:
            try:
                from agents.tools.database_tools import DatabaseTools
                
                # Get team data
                department_data = await DatabaseTools.get_department_overview()
                
                # Analyze team performance patterns
                team_insights = await self._analyze_team_patterns(department_data)
                
                # Process team insights
                for insight in team_insights:
                    await self._process_proactive_insight(insight)
                
                logger.debug("ðŸ‘¥ Team performance monitoring cycle completed")
                
            except Exception as e:
                logger.error("Team performance monitoring error", error=str(e))
            
            await asyncio.sleep(self.performance_monitoring_interval)
    
    async def _monitor_financial_metrics(self):
        """Monitor financial KPIs and cost optimization opportunities"""
        while self.monitoring_active:
            try:
                # Simulate financial monitoring (in real implementation, 
                # this would connect to financial data sources)
                financial_insights = await self._analyze_financial_patterns()
                
                for insight in financial_insights:
                    await self._process_proactive_insight(insight)
                
                logger.debug("ðŸ’° Financial metrics monitoring cycle completed")
                
            except Exception as e:
                logger.error("Financial monitoring error", error=str(e))
            
            await asyncio.sleep(self.business_monitoring_interval)
    
    async def _detect_patterns_and_trends(self):
        """Advanced pattern detection and trend analysis"""
        while self.monitoring_active:
            try:
                # Analyze historical insights for patterns
                patterns = await self._identify_recurring_patterns()
                
                # Generate meta-insights about patterns
                for pattern in patterns:
                    meta_insight = await self._create_pattern_insight(pattern)
                    if meta_insight:
                        await self._process_proactive_insight(meta_insight)
                
                logger.debug("ðŸ” Pattern detection cycle completed")
                
            except Exception as e:
                logger.error("Pattern detection error", error=str(e))
            
            await asyncio.sleep(600)  # Every 10 minutes
    
    async def _execute_autonomous_actions(self):
        """Execute pending autonomous actions"""
        while self.monitoring_active:
            try:
                # Find actions ready for execution
                pending_actions = [a for a in self.autonomous_actions 
                                 if a.status == ActionStatus.PENDING]
                
                for action in pending_actions:
                    await self._execute_single_action(action)
                
                logger.debug("ðŸ¤– Autonomous action execution cycle completed")
                
            except Exception as e:
                logger.error("Autonomous action execution error", error=str(e))
            
            await asyncio.sleep(30)  # Check every 30 seconds
    
    async def _cleanup_expired_insights(self):
        """Clean up expired insights and actions"""
        while self.monitoring_active:
            try:
                now = datetime.now()
                
                # Remove expired insights
                self.insights_generated = [
                    insight for insight in self.insights_generated
                    if insight.expires_at is None or insight.expires_at > now
                ]
                
                # Archive completed actions older than 24 hours
                cutoff = now - timedelta(hours=24)
                completed_actions = [
                    a for a in self.autonomous_actions
                    if a.status == ActionStatus.COMPLETED and 
                       a.completed_at and a.completed_at < cutoff
                ]
                
                for action in completed_actions:
                    self.intervention_history.append(asdict(action))
                    self.autonomous_actions.remove(action)
                
                logger.debug("ðŸ§¹ Cleanup cycle completed")
                
            except Exception as e:
                logger.error("Cleanup error", error=str(e))
            
            await asyncio.sleep(3600)  # Every hour
    
    async def _analyze_business_patterns(self, projects_data: Dict, talents_data: Dict) -> List[ProactiveInsight]:
        """Analyze business data and generate intelligent insights"""
        insights = []
        
        try:
            # Project velocity analysis
            if projects_data.get("status") == "success":
                total_projects = projects_data.get("total_projects", 0)
                active_projects = projects_data.get("active_projects", 0)
                completed_projects = projects_data.get("completed", 0)
                
                if total_projects > 0:
                    active_ratio = active_projects / total_projects
                    completion_ratio = completed_projects / total_projects
                    
                    # High workload detection
                    if active_ratio > 0.7:
                        insights.append(ProactiveInsight(
                            id=str(uuid.uuid4()),
                            insight_type=InsightType.RESOURCE_OPTIMIZATION,
                            priority=Priority.MEDIUM,
                            title="High Project Load Detected",
                            description=f"Currently {active_ratio:.1%} of projects are active, indicating potential resource strain",
                            recommended_actions=[
                                "Review project priorities and deadlines",
                                "Assess team capacity and workload distribution",
                                "Consider resource reallocation or deadline adjustments",
                                "Implement project portfolio optimization"
                            ],
                            confidence_score=0.85,
                            data_sources=["project_database"],
                            business_impact="High workload may lead to decreased quality and missed deadlines",
                            risk_assessment="Medium risk of project delivery delays",
                            generated_at=datetime.now(),
                            expires_at=datetime.now() + timedelta(hours=8),
                            auto_executable=False,
                            related_agents=["project_manager", "resource_coordinator"]
                        ))
                    
                    # Low completion rate
                    if completion_ratio < 0.3 and total_projects > 5:
                        insights.append(ProactiveInsight(
                            id=str(uuid.uuid4()),
                            insight_type=InsightType.PERFORMANCE_IMPROVEMENT,
                            priority=Priority.HIGH,
                            title="Low Project Completion Rate",
                            description=f"Only {completion_ratio:.1%} of projects are completed, suggesting delivery challenges",
                            recommended_actions=[
                                "Conduct project retrospectives to identify blockers",
                                "Review project planning and estimation processes",
                                "Implement better progress tracking and milestone management",
                                "Consider process improvements or team training"
                            ],
                            confidence_score=0.9,
                            data_sources=["project_database"],
                            business_impact="Low completion rates affect customer satisfaction and revenue",
                            risk_assessment="High risk of customer churn and revenue loss",
                            generated_at=datetime.now(),
                            expires_at=datetime.now() + timedelta(hours=12),
                            auto_executable=False,
                            related_agents=["project_manager", "delivery_manager", "process_improvement_specialist"]
                        ))
            
            # Talent optimization analysis
            if talents_data.get("status") == "success":
                total_talents = talents_data.get("total_talents", 0)
                active_talents = talents_data.get("active_talents", 0)
                admin_count = talents_data.get("admin_count", 0)
                
                if total_talents > 0:
                    admin_ratio = admin_count / total_talents
                    utilization_ratio = active_talents / total_talents
                    
                    # Admin ratio analysis
                    if admin_ratio < 0.05:  # Less than 5% admins
                        insights.append(ProactiveInsight(
                            id=str(uuid.uuid4()),
                            insight_type=InsightType.GOVERNANCE,
                            priority=Priority.LOW,
                            title="Low Administrative Coverage",
                            description=f"Only {admin_ratio:.1%} of talents have administrative access",
                            recommended_actions=[
                                "Identify candidates for administrative roles",
                                "Review administrative responsibilities and access needs",
                                "Plan administrative training and onboarding program",
                                "Implement role-based access control review"
                            ],
                            confidence_score=0.75,
                            data_sources=["talent_database"],
                            business_impact="Insufficient admin coverage may limit operational flexibility",
                            risk_assessment="Low risk but could impact operational efficiency",
                            generated_at=datetime.now(),
                            expires_at=datetime.now() + timedelta(days=7),
                            auto_executable=True,
                            related_agents=["hr_specialist", "security_coordinator"]
                        ))
                    
                    # Low utilization
                    if utilization_ratio < 0.8:  # Less than 80% active
                        insights.append(ProactiveInsight(
                            id=str(uuid.uuid4()),
                            insight_type=InsightType.TEAM_PRODUCTIVITY,
                            priority=Priority.MEDIUM,
                            title="Talent Utilization Opportunity",
                            description=f"Only {utilization_ratio:.1%} of talents are actively engaged",
                            recommended_actions=[
                                "Review inactive talent statuses and reasons",
                                "Implement talent re-engagement programs",
                                "Assess skill gaps and training opportunities",
                                "Optimize talent allocation across projects"
                            ],
                            confidence_score=0.8,
                            data_sources=["talent_database"],
                            business_impact="Underutilized talent represents missed productivity opportunities",
                            risk_assessment="Medium opportunity cost of unused talent capacity",
                            generated_at=datetime.now(),
                            expires_at=datetime.now() + timedelta(hours=24),
                            auto_executable=False,
                            related_agents=["hr_specialist", "talent_coordinator", "performance_analyst"]
                        ))
        
        except Exception as e:
            logger.error("Business pattern analysis error", error=str(e))
        
        return insights
    
    async def _detect_system_anomalies(self, health_data: Dict) -> List[SystemAnomaly]:
        """Detect system anomalies from health data"""
        anomalies = []
        
        try:
            if health_data.get("status") == "unhealthy":
                anomalies.append(SystemAnomaly(
                    id=str(uuid.uuid4()),
                    anomaly_type="system_health_degradation",
                    severity=Priority.HIGH,
                    affected_components=["database"],
                    impact_assessment="Database connectivity issues affecting system operations",
                    auto_resolution_available=False,
                    escalation_required=True,
                    detected_at=datetime.now(),
                    resolution_eta=datetime.now() + timedelta(minutes=30)
                ))
            
            # Check database table counts for anomalies
            database_info = health_data.get("database", {})
            tables = database_info.get("tables", {})
            
            # Detect empty critical tables
            critical_tables = ["talents", "documents"]
            for table in critical_tables:
                count = tables.get(table, 0)
                if count == 0:
                    anomalies.append(SystemAnomaly(
                        id=str(uuid.uuid4()),
                        anomaly_type="empty_critical_table",
                        severity=Priority.MEDIUM,
                        affected_components=[f"database.{table}"],
                        impact_assessment=f"Empty {table} table may indicate data loss or initialization issues",
                        auto_resolution_available=True,
                        escalation_required=False,
                        detected_at=datetime.now()
                    ))
        
        except Exception as e:
            logger.error("System anomaly detection error", error=str(e))
        
        return anomalies
    
    async def _analyze_team_patterns(self, department_data: Dict) -> List[ProactiveInsight]:
        """Analyze team performance and collaboration patterns"""
        insights = []
        
        try:
            if department_data.get("status") == "success":
                team_structure = department_data.get("team_structure", [])
                total_people = department_data.get("total_people", 0)
                
                if team_structure:
                    # Analyze management structure
                    managers = [person for person in team_structure if person.get("subordinates_count", 0) > 0]
                    manager_ratio = len(managers) / max(total_people, 1)
                    
                    # Check for management bottlenecks
                    overloaded_managers = [m for m in managers if m.get("subordinates_count", 0) > 10]
                    
                    if overloaded_managers:
                        insights.append(ProactiveInsight(
                            id=str(uuid.uuid4()),
                            insight_type=InsightType.TEAM_PRODUCTIVITY,
                            priority=Priority.HIGH,
                            title="Management Bottleneck Detected",
                            description=f"{len(overloaded_managers)} managers have excessive direct reports",
                            recommended_actions=[
                                "Review organizational structure and span of control",
                                "Consider promoting senior team members to management roles",
                                "Implement team lead positions to distribute management load",
                                "Provide management training and support tools"
                            ],
                            confidence_score=0.9,
                            data_sources=["talent_database", "organizational_structure"],
                            business_impact="Overloaded managers can become bottlenecks affecting team productivity",
                            risk_assessment="High risk of management burnout and decreased team effectiveness",
                            generated_at=datetime.now(),
                            expires_at=datetime.now() + timedelta(days=3),
                            auto_executable=False,
                            related_agents=["hr_specialist", "organizational_designer", "management_coach"]
                        ))
                    
                    # Analyze department distribution
                    departments = {}
                    for person in team_structure:
                        dept = person.get("department", "Unknown")
                        departments[dept] = departments.get(dept, 0) + 1
                    
                    # Check for unbalanced departments
                    if len(departments) > 1:
                        dept_sizes = list(departments.values())
                        max_dept = max(dept_sizes)
                        min_dept = min(dept_sizes)
                        
                        if max_dept > min_dept * 3:  # 3x imbalance
                            insights.append(ProactiveInsight(
                                id=str(uuid.uuid4()),
                                insight_type=InsightType.RESOURCE_OPTIMIZATION,
                                priority=Priority.MEDIUM,
                                title="Department Size Imbalance",
                                description="Significant size differences between departments detected",
                                recommended_actions=[
                                    "Review department resource allocation",
                                    "Consider cross-department collaboration opportunities",
                                    "Assess workload distribution across departments",
                                    "Plan strategic resource rebalancing"
                                ],
                                confidence_score=0.75,
                                data_sources=["organizational_structure"],
                                business_impact="Unbalanced departments may indicate resource misallocation",
                                risk_assessment="Medium risk of operational inefficiencies",
                                generated_at=datetime.now(),
                                expires_at=datetime.now() + timedelta(days=7),
                                auto_executable=True,
                                related_agents=["organizational_designer", "resource_coordinator"]
                            ))
        
        except Exception as e:
            logger.error("Team pattern analysis error", error=str(e))
        
        return insights
    
    async def _analyze_financial_patterns(self) -> List[ProactiveInsight]:
        """Analyze financial patterns and cost optimization opportunities"""
        insights = []
        
        try:
            # Simulate financial analysis (in real implementation, 
            # this would integrate with financial systems)
            current_time = datetime.now()
            
            # Generate cost optimization insight
            insights.append(ProactiveInsight(
                id=str(uuid.uuid4()),
                insight_type=InsightType.COST_OPTIMIZATION,
                priority=Priority.MEDIUM,
                title="Infrastructure Cost Optimization Opportunity",
                description="Analysis suggests potential for cloud infrastructure cost reduction",
                recommended_actions=[
                    "Review current cloud resource utilization",
                    "Implement auto-scaling policies",
                    "Consider reserved instance pricing",
                    "Optimize database query performance to reduce compute costs"
                ],
                confidence_score=0.7,
                data_sources=["infrastructure_metrics", "cost_analysis"],
                business_impact="Potential 15-20% reduction in infrastructure costs",
                risk_assessment="Low risk with high potential savings",
                generated_at=current_time,
                expires_at=current_time + timedelta(days=30),
                auto_executable=True,
                related_agents=["devops_specialist", "cost_analyst", "infrastructure_architect"]
            ))
        
        except Exception as e:
            logger.error("Financial pattern analysis error", error=str(e))
        
        return insights
    
    async def _process_proactive_insight(self, insight: ProactiveInsight):
        """Process and potentially act on proactive insights"""
        self.insights_generated.append(insight)
        self.metrics["insights_generated_today"] += 1
        
        logger.info("ðŸ’¡ Ali generated proactive insight", 
                   type=insight.insight_type.value, 
                   priority=insight.priority.value,
                   confidence=insight.confidence_score,
                   title=insight.title)
        
        # Auto-execute high-confidence, low-risk actions
        if (insight.auto_executable and 
            insight.confidence_score > 0.8 and 
            insight.priority in [Priority.LOW, Priority.MEDIUM]):
            
            await self._create_autonomous_action(insight)
        
        # Always queue for human visibility
        await self._queue_for_human_review(insight)
    
    async def _create_autonomous_action(self, insight: ProactiveInsight):
        """Create autonomous action based on insight"""
        action = AutonomousAction(
            id=str(uuid.uuid4()),
            action_type=f"auto_{insight.insight_type.value}",
            description=f"Autonomous action for: {insight.title}",
            insight_id=insight.id,
            status=ActionStatus.PENDING,
            agents_involved=insight.related_agents,
            parameters={
                "insight_id": insight.id,
                "actions": insight.recommended_actions,
                "priority": insight.priority.value
            },
            started_at=datetime.now()
        )
        
        self.autonomous_actions.append(action)
        logger.info("ðŸ¤– Ali created autonomous action", 
                   action_id=action.id, 
                   action_type=action.action_type)
    
    async def _execute_single_action(self, action: AutonomousAction):
        """Execute a single autonomous action"""
        try:
            action.status = ActionStatus.IN_PROGRESS
            logger.info("âš™ï¸ Ali executing autonomous action", action_id=action.id)
            
            # Simulate action execution
            await asyncio.sleep(1)  # Simulate processing time
            
            # In real implementation, this would coordinate with actual agents
            result = {
                "status": "completed",
                "agents_contacted": action.agents_involved,
                "actions_recommended": action.parameters.get("actions", []),
                "execution_time": datetime.now().isoformat()
            }
            
            action.status = ActionStatus.COMPLETED
            action.completed_at = datetime.now()
            action.result = result
            
            self.metrics["autonomous_actions_taken"] += 1
            logger.info("âœ… Ali completed autonomous action", 
                       action_id=action.id, 
                       result=result["status"])
        
        except Exception as e:
            action.status = ActionStatus.FAILED
            action.error_message = str(e)
            logger.error("âŒ Ali autonomous action failed", 
                        action_id=action.id, 
                        error=str(e))
    
    async def _handle_system_anomaly(self, anomaly: SystemAnomaly):
        """Handle detected system anomaly"""
        logger.warning("ðŸš¨ Ali detected system anomaly", 
                      anomaly_type=anomaly.anomaly_type,
                      severity=anomaly.severity.value,
                      components=anomaly.affected_components)
        
        if anomaly.auto_resolution_available:
            # Create autonomous action for anomaly resolution
            insight = ProactiveInsight(
                id=str(uuid.uuid4()),
                insight_type=InsightType.SYSTEM_HEALTH,
                priority=anomaly.severity,
                title=f"System Anomaly: {anomaly.anomaly_type}",
                description=anomaly.impact_assessment,
                recommended_actions=[
                    "Investigate affected components",
                    "Apply automated resolution if available",
                    "Monitor system recovery",
                    "Document resolution for future reference"
                ],
                confidence_score=0.9,
                data_sources=["system_monitoring"],
                business_impact="System anomaly may affect user experience",
                risk_assessment="Immediate attention required",
                generated_at=anomaly.detected_at,
                auto_executable=True,
                related_agents=["devops_specialist", "system_administrator"]
            )
            
            await self._process_proactive_insight(insight)
    
    async def _queue_for_human_review(self, insight: ProactiveInsight):
        """Queue insight for human review and notification"""
        # In real implementation, this would send notifications
        # via email, Slack, dashboard, etc.
        logger.info("ðŸ“‹ Ali queued insight for human review", 
                   insight_id=insight.id,
                   priority=insight.priority.value)
    
    async def _identify_recurring_patterns(self) -> List[Dict[str, Any]]:
        """Identify recurring patterns in historical data"""
        patterns = []
        
        try:
            # Analyze insight types frequency
            insight_types = {}
            for insight in self.insights_generated[-50:]:  # Last 50 insights
                insight_type = insight.insight_type.value
                insight_types[insight_type] = insight_types.get(insight_type, 0) + 1
            
            # Find recurring patterns
            for insight_type, count in insight_types.items():
                if count >= 3:  # Recurring if appears 3+ times
                    patterns.append({
                        "type": "recurring_insight",
                        "insight_type": insight_type,
                        "frequency": count,
                        "pattern": f"Recurring {insight_type} insights detected"
                    })
        
        except Exception as e:
            logger.error("Pattern identification error", error=str(e))
        
        return patterns
    
    async def _create_pattern_insight(self, pattern: Dict[str, Any]) -> Optional[ProactiveInsight]:
        """Create meta-insight about detected patterns"""
        try:
            if pattern["type"] == "recurring_insight":
                return ProactiveInsight(
                    id=str(uuid.uuid4()),
                    insight_type=InsightType.STRATEGIC_OPPORTUNITY,
                    priority=Priority.MEDIUM,
                    title=f"Recurring Pattern: {pattern['insight_type']}",
                    description=f"Pattern detected: {pattern['pattern']} (frequency: {pattern['frequency']})",
                    recommended_actions=[
                        "Investigate root causes of recurring issues",
                        "Implement systematic improvements",
                        "Create preventive measures",
                        "Establish monitoring for early detection"
                    ],
                    confidence_score=0.85,
                    data_sources=["pattern_analysis"],
                    business_impact="Addressing recurring patterns can prevent future issues",
                    risk_assessment="Proactive pattern resolution reduces long-term risk",
                    generated_at=datetime.now(),
                    expires_at=datetime.now() + timedelta(days=14),
                    auto_executable=False,
                    related_agents=["process_improvement_specialist", "data_analyst"]
                )
        
        except Exception as e:
            logger.error("Pattern insight creation error", error=str(e))
        
        return None
    
    def _update_system_health_score(self, health_data: Dict):
        """Update overall system health score"""
        try:
            if health_data.get("status") == "healthy":
                self.metrics["system_health_score"] = min(100.0, self.metrics["system_health_score"] + 1.0)
            else:
                self.metrics["system_health_score"] = max(0.0, self.metrics["system_health_score"] - 5.0)
        except Exception as e:
            logger.error("Health score update error", error=str(e))
    
    async def get_proactive_dashboard(self) -> Dict[str, Any]:
        """Get Ali's comprehensive proactive intelligence dashboard"""
        try:
            # Calculate metrics
            total_insights = len(self.insights_generated)
            today_insights = len([i for i in self.insights_generated 
                                if i.generated_at.date() == datetime.now().date()])
            
            high_priority_insights = len([i for i in self.insights_generated 
                                        if i.priority == Priority.HIGH])
            
            completed_actions = len([a for a in self.autonomous_actions 
                                   if a.status == ActionStatus.COMPLETED])
            
            average_confidence = (sum(i.confidence_score for i in self.insights_generated) / 
                                max(total_insights, 1))
            
            recent_insights = sorted(
                self.insights_generated[-10:], 
                key=lambda x: x.generated_at, 
                reverse=True
            )
            
            recent_actions = sorted(
                self.autonomous_actions[-5:],
                key=lambda x: x.started_at,
                reverse=True
            )
            
            return {
                "monitoring_status": "active" if self.monitoring_active else "inactive",
                "system_health_score": self.metrics["system_health_score"],
                
                # Insight metrics
                "insights": {
                    "total_generated": total_insights,
                    "generated_today": today_insights,
                    "high_priority": high_priority_insights,
                    "average_confidence": round(average_confidence, 2)
                },
                
                # Action metrics
                "autonomous_actions": {
                    "total_taken": completed_actions,
                    "pending": len([a for a in self.autonomous_actions 
                                  if a.status == ActionStatus.PENDING]),
                    "in_progress": len([a for a in self.autonomous_actions 
                                      if a.status == ActionStatus.IN_PROGRESS]),
                    "success_rate": self._calculate_success_rate()
                },
                
                # Recent activity
                "recent_insights": [
                    {
                        "id": i.id,
                        "type": i.insight_type.value,
                        "priority": i.priority.value,
                        "title": i.title,
                        "confidence": i.confidence_score,
                        "generated_at": i.generated_at.isoformat()
                    }
                    for i in recent_insights
                ],
                
                "recent_actions": [
                    {
                        "id": a.id,
                        "type": a.action_type,
                        "status": a.status.value,
                        "description": a.description,
                        "started_at": a.started_at.isoformat()
                    }
                    for a in recent_actions
                ],
                
                # System status
                "anomalies_detected": len(self.anomalies_detected),
                "intervention_history_count": len(self.intervention_history),
                
                "timestamp": datetime.now().isoformat()
            }
        
        except Exception as e:
            logger.error("Dashboard generation error", error=str(e))
            return {"error": "Dashboard generation failed", "timestamp": datetime.now().isoformat()}
    
    def _calculate_success_rate(self) -> float:
        """Calculate success rate of autonomous actions"""
        try:
            total_actions = len([a for a in self.autonomous_actions 
                               if a.status in [ActionStatus.COMPLETED, ActionStatus.FAILED]])
            
            if total_actions == 0:
                return 0.0
            
            successful_actions = len([a for a in self.autonomous_actions 
                                    if a.status == ActionStatus.COMPLETED])
            
            return round(successful_actions / total_actions, 2)
        
        except Exception as e:
            logger.error("Success rate calculation error", error=str(e))
            return 0.0
    
    async def force_insight_generation(self) -> List[ProactiveInsight]:
        """Force generation of insights for testing/demo purposes"""
        logger.info("ðŸ”¬ Ali force-generating insights for demonstration")
        
        insights = []
        
        # Generate sample insights
        sample_insights = [
            ProactiveInsight(
                id=str(uuid.uuid4()),
                insight_type=InsightType.PERFORMANCE_IMPROVEMENT,
                priority=Priority.MEDIUM,
                title="Database Query Optimization Opportunity",
                description="Analysis shows 15% of database queries exceed optimal response time",
                recommended_actions=[
                    "Review and optimize slow-running queries",
                    "Add strategic database indexes",
                    "Implement query result caching",
                    "Consider database connection pooling optimization"
                ],
                confidence_score=0.9,
                data_sources=["database_performance_metrics"],
                business_impact="Improved response times will enhance user experience",
                risk_assessment="Low risk, high reward optimization",
                generated_at=datetime.now(),
                expires_at=datetime.now() + timedelta(days=7),
                auto_executable=True,
                related_agents=["database_administrator", "performance_analyst"]
            ),
            
            ProactiveInsight(
                id=str(uuid.uuid4()),
                insight_type=InsightType.STRATEGIC_OPPORTUNITY,
                priority=Priority.HIGH,
                title="Cross-Department Collaboration Opportunity",
                description="Data suggests significant synergy potential between Engineering and Design teams",
                recommended_actions=[
                    "Organize cross-functional workshops",
                    "Establish regular design-engineering sync meetings",
                    "Create shared project spaces and tools",
                    "Implement collaborative design review processes"
                ],
                confidence_score=0.85,
                data_sources=["team_interaction_analysis", "project_success_metrics"],
                business_impact="Enhanced collaboration could improve project delivery by 25%",
                risk_assessment="Medium investment, high potential return",
                generated_at=datetime.now(),
                expires_at=datetime.now() + timedelta(days=14),
                auto_executable=False,
                related_agents=["team_coordinator", "collaboration_specialist", "project_manager"]
            )
        ]
        
        for insight in sample_insights:
            await self._process_proactive_insight(insight)
            insights.append(insight)
        
        return insights


# Global Ali Proactive Engine instance
ali_proactive_engine = AliProactiveEngine()