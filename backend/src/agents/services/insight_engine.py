"""
Insight Engine - Intelligent pattern recognition and recommendations
Ali's proactive intelligence system
"""

from typing import Dict, List, Any, Optional, Callable, Set, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
import json
import uuid
from collections import defaultdict
import asyncio
import re

import structlog
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from ..event_bus import Event, EventType, EventPriority, event_bus
from ..telemetry import TelemetryService
from ...models.project import Task, Project, TaskStatus

logger = structlog.get_logger()


class InsightType(str, Enum):
    PERFORMANCE = "performance"
    BOTTLENECK = "bottleneck"
    RISK = "risk"
    OPPORTUNITY = "opportunity"
    RECOMMENDATION = "recommendation"
    PREDICTION = "prediction"
    ANOMALY = "anomaly"


class InsightSeverity(str, Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    SUCCESS = "success"


@dataclass
class Insight:
    """Represents an insight generated by the engine"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    type: InsightType = InsightType.RECOMMENDATION
    severity: InsightSeverity = InsightSeverity.INFO
    title: str = ""
    description: str = ""
    context: Dict[str, Any] = field(default_factory=dict)
    recommendations: List[str] = field(default_factory=list)
    metrics: Dict[str, Any] = field(default_factory=dict)
    source: str = "insight_engine"
    timestamp: datetime = field(default_factory=datetime.utcnow)
    expires_at: Optional[datetime] = None
    is_actionable: bool = True
    confidence: float = 0.8
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "type": self.type,
            "severity": self.severity,
            "title": self.title,
            "description": self.description,
            "context": self.context,
            "recommendations": self.recommendations,
            "metrics": self.metrics,
            "timestamp": self.timestamp.isoformat(),
            "expires_at": self.expires_at.isoformat() if self.expires_at else None,
            "is_actionable": self.is_actionable,
            "confidence": self.confidence
        }


@dataclass
class Rule:
    """Rule for generating insights"""
    id: str
    name: str
    description: str
    type: InsightType
    condition: Callable[[Dict[str, Any]], bool]
    action: Callable[[Dict[str, Any]], Insight]
    priority: int = 5
    enabled: bool = True
    cooldown: timedelta = timedelta(minutes=30)
    last_triggered: Optional[datetime] = None
    
    def can_trigger(self) -> bool:
        """Check if rule can be triggered based on cooldown"""
        if not self.enabled:
            return False
        
        if self.last_triggered:
            elapsed = datetime.utcnow() - self.last_triggered
            if elapsed < self.cooldown:
                return False
        
        return True
    
    def trigger(self, context: Dict[str, Any]) -> Optional[Insight]:
        """Trigger the rule if conditions are met"""
        if not self.can_trigger():
            return None
        
        if self.condition(context):
            self.last_triggered = datetime.utcnow()
            return self.action(context)
        
        return None


class InsightEngine:
    """Main insight engine for proactive intelligence"""
    
    def __init__(self, telemetry: Optional[TelemetryService] = None):
        self.telemetry = telemetry
        self.rules: Dict[str, Rule] = {}
        self.insights: deque = deque(maxlen=1000)
        self.insight_subscribers: List[Callable] = []
        self.context_cache: Dict[str, Any] = {}
        self.running = False
        self._analyzer_task = None
        
        # Metrics
        self.metrics = {
            "insights_generated": 0,
            "rules_triggered": 0,
            "actions_taken": 0,
            "errors": 0
        }
        
        # Initialize default rules
        self._register_default_rules()
    
    async def start(self):
        """Start the insight engine"""
        if not self.running:
            self.running = True
            self._analyzer_task = asyncio.create_task(self._analyze_loop())
            
            # Subscribe to event patterns
            self._subscribe_to_patterns()
            
            logger.info("ðŸ§  Insight engine started")
    
    async def stop(self):
        """Stop the insight engine"""
        self.running = False
        if self._analyzer_task:
            await self._analyzer_task
            logger.info("ðŸ›‘ Insight engine stopped")
    
    def register_rule(self, rule: Rule):
        """Register a new rule"""
        self.rules[rule.id] = rule
        logger.info(f"ðŸ“‹ Rule registered: {rule.name}")
    
    def subscribe_to_insights(self, handler: Callable):
        """Subscribe to insight generation events"""
        self.insight_subscribers.append(handler)
    
    async def generate_insight(self, insight: Insight):
        """Generate and publish an insight"""
        self.insights.append(insight)
        self.metrics["insights_generated"] += 1
        
        # Notify subscribers
        for handler in self.insight_subscribers:
            try:
                if asyncio.iscoroutinefunction(handler):
                    await handler(insight)
                else:
                    handler(insight)
            except Exception as e:
                logger.error(f"âŒ Error in insight handler: {e}")
        
        # Publish to event bus
        await event_bus.publish(Event(
            type=EventType.INSIGHT_GENERATED,
            priority=self._map_severity_to_priority(insight.severity),
            source="insight_engine",
            data=insight.to_dict()
        ))
        
        logger.info(f"ðŸ’¡ Insight generated: {insight.title}",
                   insight_type=insight.type,
                   severity=insight.severity)
    
    async def _analyze_loop(self):
        """Main analysis loop"""
        while self.running:
            try:
                # Gather context
                context = await self._gather_context()
                
                # Run rules
                await self._run_rules(context)
                
                # Wait before next analysis
                await asyncio.sleep(30)  # Run every 30 seconds
                
            except Exception as e:
                logger.error(f"âŒ Error in analysis loop: {e}")
                self.metrics["errors"] += 1
                await asyncio.sleep(60)
    
    async def _gather_context(self) -> Dict[str, Any]:
        """Gather current system context"""
        context = {
            "timestamp": datetime.utcnow(),
            "event_metrics": event_bus.get_metrics()
        }
        
        # Add telemetry data if available
        if self.telemetry:
            context["telemetry"] = await self.telemetry.get_recent_metrics()
        
        # Add cached context
        context.update(self.context_cache)
        
        return context
    
    async def _run_rules(self, context: Dict[str, Any]):
        """Run all enabled rules against context"""
        # Sort rules by priority
        sorted_rules = sorted(
            self.rules.values(),
            key=lambda r: r.priority,
            reverse=True
        )
        
        for rule in sorted_rules:
            try:
                insight = rule.trigger(context)
                if insight:
                    await self.generate_insight(insight)
                    self.metrics["rules_triggered"] += 1
            except Exception as e:
                logger.error(f"âŒ Error running rule {rule.name}: {e}")
    
    def _subscribe_to_patterns(self):
        """Subscribe to relevant event patterns"""
        
        # High error rate pattern
        async def handle_high_errors(pattern_event: Event, events: List[Event]):
            insight = Insight(
                type=InsightType.RISK,
                severity=InsightSeverity.CRITICAL,
                title="High Error Rate Detected",
                description=f"System experiencing {len(events)} errors in short time period",
                recommendations=[
                    "Review recent deployments",
                    "Check system resources",
                    "Enable debug logging",
                    "Alert on-call engineer"
                ],
                metrics={"error_count": len(events)},
                confidence=0.95
            )
            await self.generate_insight(insight)
        
        event_bus.subscribe_to_pattern("high_error_rate", handle_high_errors)
        
        # Workflow failures pattern
        async def handle_workflow_failures(pattern_event: Event, events: List[Event]):
            user_id = events[0].user_id if events else None
            insight = Insight(
                type=InsightType.BOTTLENECK,
                severity=InsightSeverity.WARNING,
                title="Repeated Workflow Failures",
                description=f"User {user_id} experiencing repeated workflow failures",
                recommendations=[
                    "Check workflow configuration",
                    "Review user permissions",
                    "Provide user assistance",
                    "Consider workflow simplification"
                ],
                context={"user_id": user_id, "failure_count": len(events)},
                confidence=0.85
            )
            await self.generate_insight(insight)
        
        event_bus.subscribe_to_pattern("workflow_failures", handle_workflow_failures)
    
    def _register_default_rules(self):
        """Register default insight generation rules"""
        
        # Performance degradation rule
        def perf_condition(ctx: Dict[str, Any]) -> bool:
            if "telemetry" not in ctx:
                return False
            metrics = ctx["telemetry"]
            return metrics.get("avg_response_time", 0) > 1000  # > 1 second
        
        def perf_action(ctx: Dict[str, Any]) -> Insight:
            return Insight(
                type=InsightType.PERFORMANCE,
                severity=InsightSeverity.WARNING,
                title="Performance Degradation Detected",
                description="Average response time exceeding threshold",
                recommendations=[
                    "Review recent code changes",
                    "Check database query performance",
                    "Consider caching frequently accessed data",
                    "Scale up resources if needed"
                ],
                metrics=ctx.get("telemetry", {}),
                confidence=0.8
            )
        
        self.register_rule(Rule(
            id="perf_degradation",
            name="Performance Degradation",
            description="Detect when system performance degrades",
            type=InsightType.PERFORMANCE,
            condition=perf_condition,
            action=perf_action,
            priority=8
        ))
        
        # Task bottleneck rule
        def bottleneck_condition(ctx: Dict[str, Any]) -> bool:
            # Check if too many tasks are blocked
            blocked_tasks = ctx.get("blocked_tasks", 0)
            return blocked_tasks > 5
        
        def bottleneck_action(ctx: Dict[str, Any]) -> Insight:
            return Insight(
                type=InsightType.BOTTLENECK,
                severity=InsightSeverity.WARNING,
                title="Task Bottleneck Identified",
                description=f"{ctx.get('blocked_tasks', 0)} tasks currently blocked",
                recommendations=[
                    "Review task dependencies",
                    "Identify blocking resources",
                    "Consider parallel execution",
                    "Assign additional agents to blocked tasks"
                ],
                context={"blocked_count": ctx.get("blocked_tasks", 0)},
                confidence=0.9
            )
        
        self.register_rule(Rule(
            id="task_bottleneck",
            name="Task Bottleneck",
            description="Detect when tasks are bottlenecked",
            type=InsightType.BOTTLENECK,
            condition=bottleneck_condition,
            action=bottleneck_action,
            priority=7
        ))
        
        # Opportunity detection rule
        def opportunity_condition(ctx: Dict[str, Any]) -> bool:
            # Check for automation opportunities
            manual_tasks = ctx.get("manual_tasks", 0)
            total_tasks = ctx.get("total_tasks", 1)
            return manual_tasks / total_tasks > 0.5
        
        def opportunity_action(ctx: Dict[str, Any]) -> Insight:
            return Insight(
                type=InsightType.OPPORTUNITY,
                severity=InsightSeverity.INFO,
                title="Automation Opportunity Detected",
                description="High percentage of manual tasks could be automated",
                recommendations=[
                    "Review manual tasks for automation potential",
                    "Deploy AI agents to suitable tasks",
                    "Implement workflow automation",
                    "Consider batch processing"
                ],
                metrics={
                    "manual_tasks": ctx.get("manual_tasks", 0),
                    "automation_potential": 0.7
                },
                confidence=0.75
            )
        
        self.register_rule(Rule(
            id="automation_opportunity",
            name="Automation Opportunity",
            description="Detect opportunities for automation",
            type=InsightType.OPPORTUNITY,
            condition=opportunity_condition,
            action=opportunity_action,
            priority=5
        ))
    
    def _map_severity_to_priority(self, severity: InsightSeverity) -> EventPriority:
        """Map insight severity to event priority"""
        mapping = {
            InsightSeverity.INFO: EventPriority.LOW,
            InsightSeverity.WARNING: EventPriority.MEDIUM,
            InsightSeverity.CRITICAL: EventPriority.CRITICAL,
            InsightSeverity.SUCCESS: EventPriority.LOW
        }
        return mapping.get(severity, EventPriority.MEDIUM)
    
    def get_insights(self, 
                    type: Optional[InsightType] = None,
                    severity: Optional[InsightSeverity] = None,
                    since: Optional[datetime] = None,
                    limit: int = 50) -> List[Insight]:
        """Get filtered insights"""
        insights = list(self.insights)
        
        if type:
            insights = [i for i in insights if i.type == type]
        
        if severity:
            insights = [i for i in insights if i.severity == severity]
        
        if since:
            insights = [i for i in insights if i.timestamp >= since]
        
        return insights[-limit:]
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get insight engine metrics"""
        return {
            **self.metrics,
            "active_rules": len([r for r in self.rules.values() if r.enabled]),
            "total_rules": len(self.rules),
            "insights_in_memory": len(self.insights)
        }


# Global insight engine instance
insight_engine = InsightEngine()


async def initialize_insight_engine(telemetry: Optional[TelemetryService] = None):
    """Initialize and start the insight engine"""
    global insight_engine
    insight_engine = InsightEngine(telemetry)
    await insight_engine.start()
    return insight_engine